---
layout: hexo
title: 什么是加密算法？
tags: [浏览器,前端]
categories: 加密算法
date: 2022-02-09 23:50:11
---

{% title h2, 浏览器加密 %}

{% note info,  浏览器的安全一直以来是人们关注的问题，为了让网上的信息不被泄漏，做出了很多努力，其中主要包括对称加密，非对称加密，以及两种加密结合的方式。 %}

{% title h2, 对称加密 %}
![对称加密](1.jpg)

{% emp 思考 %} ：
&nbsp;&nbsp;1.浏览器和服务器双方如何拿到钥匙？
&nbsp;&nbsp;2.传输钥匙会不会被截获，别人也能拿到钥匙？  
{% title h2, 非对称加密 %}
![非对称加密](2.jpg)

{% wavy 好处： %}  第三方就算截获了公钥和加密消息也没用，因为没有私钥，不能获取消息。<br/>
{% emp 思考 %} ：非对称加密非常耗时，该怎么解决？<br/>
{% title h2, 对称加密+非对称加密 %}
![对称加密+非对称加密](3.jpg)
{% wavy 好处： %}  这样双方都可以得到安全的对称加密的钥匙，虽然公钥是明文传输的但是只要私钥被自己保管，所以可以保证钥匙的安全。这样就可以用钥匙(对称加密)进行消息的加密了。也解决了多次非对称加密的产生的时间损耗问题。  <br/>
{% emp 思考 %} ：如果中间人获取公钥之后，发送了自己的公钥，那他就能破解浏览器用他的公钥加密之后的密钥，他还能把密钥用刚才获取的公钥进行加密发送给服务器，这样双方都不会发觉密钥已经泄漏了。<br/>
{% note warning, 经过这几步操作，其实还是逃不过一个问题，如何证明你的身份，也就是说怎么证明公钥是你的？ %}
{% p center large blue, 那就是数字证书！！ %}
![数字证书](4.jpg)
    1.CA机构拥有非对称加密的私钥和公钥。 
    2.CA机构对证书明文数据T进行hash。 
    3.对hash后的值用私钥加密，得到数字签名S。
    4.数字签名+明文数据=数字证书
![浏览器验证](5.jpg)
    1.浏览器拿到证书，得到明文T，签名S。
    2.用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥）得到S’。
    3.用证书里指明的hash算法对明文T进行hash得到T’。
    4.显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。
    5.所以此时比较S’是否等于T’，等于则表明证书可信。
{% p warning, 中间人有可能篡改该证书吗？ %}
&nbsp;&nbsp;假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。
{% p warning, 既然不可能篡改，那整个证书被掉包呢？ %}
&nbsp;&nbsp;假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？**但是**其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。
&nbsp;&nbsp;**操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。**
{% note info,  数据被哈希的原因：因为非对称加密比较耗时，但是hash之后得到的是固定长度的信息，这样加解密比较方便。非对称加密可以加密的消息体长度有上限，必须先hash保证定长结果。 %}
![完整流程](image.png)
&nbsp;&nbsp;ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。 这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中。
![CA证书](ca.png)

  






