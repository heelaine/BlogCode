---
title: tcp&udp
author: helaine
swiper: true
top: true
date: 2022-02-10 15:13:20
tags: ['浏览器','计算机网络']
categories: tcp&udp
---
{% note info,  在了解tcp和udp之前，可以先对计算机网络做一些简单的了解。 %}

{% title h2, 网络模型 %}
**五层模型**：
* 物理层
* 数据链路层
* 网络层  (主机之间通信)
* 传输层  (应用程序间通信)
* 应用层 

**七层模型**：
* 物理层
* 数据链路层
* 网络层
* 传输层
* 会话层，表示层，应用层

**传输过程中文件会被拆分成多个数据包来传输**

{% wavy 补充： %}
* mac地址：也称物理地址(硬件地址)，由网络设备制造商生产时写在硬件内部，无论接到哪个网络，都拥有相同的mac地址。
* IP：IP数据报送到目的主机(主机之间的逻辑通信)，计算机的地址就是ip地址 访问网站就是你的计算机向另外一台计算机请求信息,但是IP只负责传送到对方电脑，不知道哪个程序，所以在发送前会加上主机的ip地址。
* UDP：用户数据包协议 （通过端口号UDP把指定数据包发送给程序）（应用程序之间通信）

{% pbg yellow, udp %}对于{% pbg yellow, 错误的数据包 %}：udp不重发，直接丢弃当前的包，并且udp发送之后不知道能不能到达目的地。<br/>

{% pbg yellow, udp的问题 %}：1.数据包容易丢失。2.大文件拆分成小数据包传输的时候不知道如何组装这些数据包，把他们还原成完整的文件。<br/>

而{% pbg yellow, tcp %}解决了udp的问题 ：如果数据包丢失的话就重传。tcp引入了{% pbg yellow, 数据包排序机制%}，把打乱的数据包组合成完整的文件。所以tcp头包含了**目标端口**和**本机端口**，还提供了**排序的序列号**。(TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度)。所以tcp是一种{% pbg yellow, 面向连接 %}，{% pbg yellow, 可靠的 %}，{% pbg yellow, 基于字节流 %}的传输层通信协议。

{% title h2, 浏览器和服务器交互过程 %}
![服务器和客户端传输过程](1.png)
**首先，建立连接阶段。**这个阶段是通过“{% pbg yellow, 三次握手 %}”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送{% pbg yellow, 三个数据包 %}以确认连接的建立。
**其次，传输数据阶段。**在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，{% pbg yellow, 在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制 %}。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。
**最后，断开连接阶段。**数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

{% title h2, TCP和UDP的不同 %}
|  TCP   |  UDP  |
|--------|-------|
| 可靠的  |不可靠的|
|面向连接的|无连接的|
|传输效率低|传输效率高|
|对系统资源要求高|对系统资源要求低|
|少量数据|大量数据|
|每次连接只有两个端点|支持一对一，一对多，多对多|
|拥塞控制，网络拥塞会导致效率变低|没有拥塞控制|
|面向字节流，根据对方的窗口之和网络拥塞程度来决定报文段包含多少字节，如果数据块太长，可以划分短一点在传送|面向报文，一次性交付一个完整报文。|
|提供双全工通信，在发送和接受都设置缓存，临时存放数据||

{% title h2, 三次握手 %}
![三次握手](2.png)
**第一次握手**
客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 {% pbg yellow, SYN-SENT %} 状态。
**第二次握手**
服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入{% pbg yellow, SYN-RECEIVED %}  状态。
**第三次握手**
当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入了{% pbg yellow, ESTABLISHED %}  状态，服务端收到这个应答后也进入 {% pbg yellow, ESTABLISHED %} 状态，此时连接建立成功。
{% wavy 只有两次怎么办？ %}
如果只有 2 次的话，服务器并不清楚浏览器是否收到他发过去的信息，可能会一直发送消息。

{% title h2, 四次挥手 %}
![四次挥手](3.png)
**第一次挥手**
若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。
**第二次挥手**
B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 {% pbg yellow, CLOSE_WAIT %} 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。
**第三次挥手**
B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入{% pbg yellow, LAST-ACK %}  状态。
**PS**：通过延迟确认的技术(通常有时间限制，否则对方会误认为需要重传)，可以将第二次和第三次握手合并，延迟 ACK 包的发送。
**第四次挥手**
A 收到释放请求后，向 B 发送确认应答，此时 A 进入 {% pbg yellow, TIME-WAIT %} 状态。该状态会持续 2MSL(最长报文段寿命，指报文段在网络中生存的时间，超时会被抛弃) 时间，若该时间段内没有 B 的重发请求的话，就进入 {% pbg yellow, CLOSED %} 状态。当 B 收到确认应答后，也便进入 {% pbg yellow, CLOSED %} 状态。

## http和TCP的关系
TCP 协议对应于传输层，而 HTTP 协议对应于应用层，从本质上来说，二者没有可比性：
* HTTP 对应于应用层，TCP 协议对应于传输层
* HTTP 是无状态的短连接，而 TCP 是有状态的长连接
* HTTP 协议是在 TCP 协议之上建立的，HTTP 在发起请求时通过 TCP 协议建立起连接服务器的通道，请求结束后，立即断开 TCP 连接
* TCP是传输层协议，定义的是数据传输和连接方式的规范，HTTP是应用层协议，定义的是传输数据的内容的规范。
![过程](4.png)




